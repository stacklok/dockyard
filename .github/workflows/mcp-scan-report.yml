# This workflow runs in the context of the base repository and has write access
# to post PR comments, even for PRs from forks. It triggers after the main
# build-containers workflow completes and downloads scan result artifacts.
name: MCP Scan Report

on:
  workflow_run:
    workflows: ["Build MCP Server Containers"]
    types: [completed]

permissions:
  pull-requests: write

jobs:
  mcp-scan-report:
    runs-on: ubuntu-latest
    if: github.event.workflow_run.event == 'pull_request'
    steps:
      - name: Download PR number artifact
        id: pr-number
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7
        with:
          name: pr-number
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Read PR number
        id: read-pr
        run: |
          PR_NUMBER=$(cat pr-number.txt)
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "PR number: $PR_NUMBER"

      - name: Download scan results
        id: scan-results
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7
        with:
          pattern: mcp-scan-*
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: scan-artifacts
        continue-on-error: true

      - name: Comment PR with scan results
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const prNumber = parseInt('${{ steps.read-pr.outputs.pr_number }}');
            console.log('Commenting on PR:', prNumber);

            let comment = '## ðŸ”’ MCP Security Scan Results\n\n';
            let hasAnyIssues = false;
            let totalServersScanned = 0;
            let totalVulnerabilities = 0;

            // Find all scan summary files in the scan-artifacts directory
            const summaryFiles = [];
            const artifactsDir = 'scan-artifacts';

            if (fs.existsSync(artifactsDir)) {
              const artifactDirs = fs.readdirSync(artifactsDir);
              console.log('Artifact contents:', artifactDirs);

              for (const item of artifactDirs) {
                const itemPath = path.join(artifactsDir, item);
                const stat = fs.statSync(itemPath);

                if (stat.isDirectory()) {
                  const summaryFile = path.join(itemPath, 'scan-summary.json');
                  if (fs.existsSync(summaryFile)) {
                    summaryFiles.push(summaryFile);
                    console.log('Found summary file in directory:', summaryFile);
                  }
                } else if (stat.isFile() && item === 'scan-summary.json') {
                  summaryFiles.push(itemPath);
                  console.log('Found summary file directly:', itemPath);
                }
              }
            }

            console.log('Total summary files found:', summaryFiles.length);

            if (summaryFiles.length === 0) {
              comment += 'âš ï¸ No MCP servers were scanned in this PR.\n';
            } else {
              for (const file of summaryFiles) {
                try {
                  const summary = JSON.parse(fs.readFileSync(file, 'utf8'));
                  totalServersScanned++;

                  if (summary.status === 'passed') {
                    comment += `### âœ… ${summary.server}\n`;
                    comment += `- **Status**: Passed\n`;
                    comment += `- **Tools scanned**: ${summary.tools_scanned || 0}\n`;
                    comment += `- **Result**: No security issues detected\n\n`;
                  } else if (summary.status === 'failed') {
                    hasAnyIssues = true;
                    totalVulnerabilities += summary.blocking_count || 0;
                    comment += `### âŒ ${summary.server}\n`;
                    comment += `- **Status**: Failed\n`;
                    comment += `- **Tools scanned**: ${summary.tools_scanned || 0}\n`;
                    comment += `- **Vulnerabilities found**: ${summary.blocking_count || 0}\n`;
                    comment += '\n**Security issues detected:**\n';

                    if (summary.blocking_issues) {
                      summary.blocking_issues.forEach(vuln => {
                        comment += `- **[${vuln.code}]** ${vuln.message}\n`;
                      });
                    }

                    if (summary.allowed_issues && summary.allowed_issues.length > 0) {
                      comment += '\n**Allowed issues (not blocking):**\n';
                      summary.allowed_issues.forEach(vuln => {
                        comment += `- **[${vuln.code}]** ${vuln.message} _(Allowed: ${vuln.allowed_reason})_\n`;
                      });
                    }
                    comment += '\n';
                  } else if (summary.status === 'warning') {
                    comment += `### âš ï¸ ${summary.server}\n`;
                    comment += `- **Status**: Warning\n`;
                    comment += `- **Message**: ${summary.message}\n\n`;
                  } else {
                    comment += `### âš ï¸ ${summary.server}\n`;
                    comment += `- **Status**: Error\n`;
                    comment += `- **Message**: ${summary.message || 'Unknown error'}\n\n`;
                  }
                } catch (error) {
                  console.error(`Error parsing ${file}:`, error);
                  comment += `### âš ï¸ Error parsing scan results\n`;
                  comment += `Could not parse ${file}: ${error.message}\n\n`;
                }
              }

              if (totalServersScanned > 0) {
                comment += '---\n';
                comment += `**Summary**: Scanned ${totalServersScanned} MCP server(s)`;
                if (hasAnyIssues) {
                  comment += `, found ${totalVulnerabilities} security issue(s).\n\n`;
                  comment += 'âš ï¸ **Action Required**: Security issues were detected. Please review and address them before merging.\n';
                } else {
                  comment += ', all passed security checks. âœ…\n';
                }
              }
            }

            // Find and update or create comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('MCP Security Scan Results')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
              console.log(`Updated existing comment #${botComment.id}`);
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: comment
              });
              console.log('Created new comment');
            }
