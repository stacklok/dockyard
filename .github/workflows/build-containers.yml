name: Build MCP Server Containers

on:
  push:
    branches: [ main ]
    paths:
      - 'npx/**/*.yaml'
      - 'uvx/**/*.yaml'
      - 'go/**/*.yaml'
      - 'cmd/dockhand/**'
      - 'go.mod'
      - 'go.sum'
  pull_request:
    branches: [ main ]
    paths:
      - 'npx/**/*.yaml'
      - 'uvx/**/*.yaml'
      - 'go/**/*.yaml'
      - 'cmd/dockhand/**'
      - 'go.mod'
      - 'go.sum'
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  discover-configs:
    runs-on: ubuntu-latest
    outputs:
      configs: ${{ steps.find-configs.outputs.configs }}
      changed-configs: ${{ steps.find-configs.outputs.changed-configs }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          fetch-depth: 0  # Need full history for change detection

      - name: Find configuration files to build
        id: find-configs
        run: |
          # Find all spec.yaml files in protocol directories
          all_configs=$(find npx uvx go -name "spec.yaml" -type f 2>/dev/null | sort)
          
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # For manual triggers, build all configs
            configs_to_build="$all_configs"
            echo "Manual trigger - building all configurations"
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            # For PRs, build configs that changed compared to target branch
            changed_files=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)
            configs_to_build=""
            
            # Check if dockhand source, go.mod, or go.sum changed (rebuild all)
            if echo "$changed_files" | grep -E "(cmd/dockhand/|go\.mod|go\.sum)"; then
              echo "Core files changed - building all configurations"
              configs_to_build="$all_configs"
            else
              # Only build configs whose spec.yaml files changed or their parent directories changed
              for config in $all_configs; do
                config_dir=$(dirname "$config")
                # Check if spec.yaml itself changed or any file in its directory changed
                if echo "$changed_files" | grep -q "^$config$" || echo "$changed_files" | grep -q "^$config_dir/"; then
                  configs_to_build="$configs_to_build$config"$'\n'
                fi
              done
            fi
          else
            # For pushes to main, build configs that changed in this push
            changed_files=$(git diff --name-only HEAD~1..HEAD)
            configs_to_build=""
            
            # Check if dockhand source, go.mod, or go.sum changed (rebuild all)
            if echo "$changed_files" | grep -E "(cmd/dockhand/|go\.mod|go\.sum)"; then
              echo "Core files changed - building all configurations"
              configs_to_build="$all_configs"
            else
              # Only build configs whose spec.yaml files changed or their parent directories changed
              for config in $all_configs; do
                config_dir=$(dirname "$config")
                # Check if spec.yaml itself changed or any file in its directory changed
                if echo "$changed_files" | grep -q "^$config$" || echo "$changed_files" | grep -q "^$config_dir/"; then
                  configs_to_build="$configs_to_build$config"$'\n'
                fi
              done
            fi
          fi
          
          # Convert to JSON array, filtering out empty lines
          configs_json=$(echo "$configs_to_build" | grep -v '^$' | jq -R -s -c 'split("\n")[:-1]')
          all_configs_json=$(echo "$all_configs" | jq -R -s -c 'split("\n")[:-1]')
          
          echo "configs=$all_configs_json" >> $GITHUB_OUTPUT
          echo "changed-configs=$configs_json" >> $GITHUB_OUTPUT
          
          echo "All configurations: $all_configs_json"
          echo "Configurations to build: $configs_json"

  verify-provenance:
    needs: discover-configs
    runs-on: ubuntu-latest
    # Verify package provenance when we have configs to build
    if: ${{ needs.discover-configs.outputs.changed-configs != '[]' }}
    strategy:
      matrix:
        config: ${{ fromJson(needs.discover-configs.outputs.changed-configs) }}
      fail-fast: false

    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

      - name: Set up Go
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6
        with:
          go-version-file: 'go.mod'

      - name: Extract metadata from config
        id: meta
        run: |
          config_file="${{ matrix.config }}"
          protocol=$(echo "$config_file" | cut -d'/' -f1)
          server_name=$(echo "$config_file" | cut -d'/' -f2)

          echo "config_file=$config_file" >> $GITHUB_OUTPUT
          echo "protocol=$protocol" >> $GITHUB_OUTPUT
          echo "server_name=$server_name" >> $GITHUB_OUTPUT

      - name: Build dockhand
        run: go build -o /tmp/dockhand ./cmd/dockhand

      - name: Verify package provenance
        id: provenance
        run: |
          echo "ðŸ” Verifying package provenance for ${{ steps.meta.outputs.server_name }}"

          # Run provenance verification
          if /tmp/dockhand verify-provenance -c "${{ matrix.config }}" > /tmp/provenance-${{ steps.meta.outputs.server_name }}.txt 2>&1; then
            echo "provenance_passed=true" >> $GITHUB_OUTPUT
            echo "âœ… Provenance verification passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "provenance_passed=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ Provenance verification failed or package has no provenance" >> $GITHUB_STEP_SUMMARY
          fi

          # Display results
          cat /tmp/provenance-${{ steps.meta.outputs.server_name }}.txt

          # Save for artifact
          cp /tmp/provenance-${{ steps.meta.outputs.server_name }}.txt .

      - name: Upload provenance verification results
        if: always()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6
        with:
          name: provenance-${{ steps.meta.outputs.server_name }}
          path: provenance-${{ steps.meta.outputs.server_name }}.txt
          retention-days: 30

  mcp-security-scan:
    needs: [discover-configs, verify-provenance]
    runs-on: ubuntu-latest
    # Always run security scans when we have configs to build
    if: ${{ needs.discover-configs.outputs.changed-configs != '[]' }}
    strategy:
      matrix:
        config: ${{ fromJson(needs.discover-configs.outputs.changed-configs) }}
      fail-fast: false

    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

      - name: Set up Python
        uses: actions/setup-python@a309ff8b426b58ec0e2a45f0f869d46889d02405 # v6
        with:
          python-version: '3.13'

      - name: Set up uv
        uses: astral-sh/setup-uv@803947b9bd8e9f986429fa0c5a41c367cd732b41 # v7
        with:
          enable-cache: true

      - name: Install dependencies
        id: install-deps
        run: |
          # Install pinned Python dependencies from requirements.txt
          uv pip install --system -r scripts/mcp-scan/requirements.txt

          # Verify installation
          mcp-scanner --help || true

          # Capture scanner version for attestation
          SCANNER_VERSION=$(uv pip show cisco-ai-mcp-scanner | grep "^Version:" | cut -d' ' -f2)
          echo "scanner_version=$SCANNER_VERSION" >> $GITHUB_OUTPUT
          echo "Installed mcp-scanner version: $SCANNER_VERSION"

      - name: Extract metadata from config
        id: meta
        run: |
          config_file="${{ matrix.config }}"
          # Extract protocol and server name from path like "npx/context7/spec.yaml"
          protocol=$(echo "$config_file" | cut -d'/' -f1)
          server_name=$(echo "$config_file" | cut -d'/' -f2)
          
          echo "config_file=$config_file" >> $GITHUB_OUTPUT
          echo "protocol=$protocol" >> $GITHUB_OUTPUT
          echo "server_name=$server_name" >> $GITHUB_OUTPUT

      - name: Run MCP Security Scan
        id: scan
        env:
          MCP_SCANNER_ENABLE_LLM: ${{ vars.MCP_SCANNER_ENABLE_LLM || 'false' }}
          MCP_SCANNER_LLM_API_KEY: ${{ secrets.MCP_SCANNER_LLM_API_KEY }}
          MCP_SCANNER_LLM_MODEL: ${{ vars.MCP_SCANNER_LLM_MODEL || '' }}
        run: |
          echo "ðŸ” Scanning MCP server: ${{ steps.meta.outputs.server_name }}"

          # Generate config (outputs JSON with command/args)
          config_json=$(python3 scripts/mcp-scan/generate_mcp_config.py \
            "${{ matrix.config }}" \
            "${{ steps.meta.outputs.protocol }}" \
            "${{ steps.meta.outputs.server_name }}")

          command=$(echo "$config_json" | jq -r '.command')
          args=$(echo "$config_json" | jq -r '.args')

          # Run scan using Cisco AI Defense mcp-scanner
          # Note: stderr is redirected to a separate file to avoid corrupting JSON output
          scan_output="/tmp/mcp-scan-${{ steps.meta.outputs.server_name }}.json"
          scan_stderr="/tmp/mcp-scan-${{ steps.meta.outputs.server_name }}.stderr"

          if python3 scripts/mcp-scan/run_scan.py "$command" "$args" \
            > "$scan_output" 2> "$scan_stderr"; then
            echo "scan_passed=true" >> $GITHUB_OUTPUT
          else
            echo "scan_passed=false" >> $GITHUB_OUTPUT
            # Show stderr in logs for debugging
            if [ -s "$scan_stderr" ]; then
              echo "Scanner stderr output:"
              cat "$scan_stderr"
            fi
          fi

          # Process results (pass the config file to check for allowed issues)
          python3 scripts/mcp-scan/process_scan_results.py \
            "$scan_output" \
            "${{ steps.meta.outputs.server_name }}" \
            "${{ matrix.config }}" \
            > scan-summary.json

          # Copy scan output to current directory for artifact upload
          cp "$scan_output" "mcp-scan-${{ steps.meta.outputs.server_name }}.json"

          # Save scanner version for attestation (from install-deps step)
          echo "${{ steps.install-deps.outputs.scanner_version }}" > scanner-version.txt

      - name: Upload scan results
        if: always()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6
        with:
          name: mcp-scan-${{ steps.meta.outputs.server_name }}
          path: |
            mcp-scan-${{ steps.meta.outputs.server_name }}.json
            scan-summary.json
            scanner-version.txt
          retention-days: 30

  build-containers:
    needs: [discover-configs, verify-provenance, mcp-security-scan]
    runs-on: ubuntu-latest
    timeout-minutes: 60
    # Only proceed if security scans passed (provenance check is informational only)
    if: ${{ needs.discover-configs.outputs.changed-configs != '[]' && needs.mcp-security-scan.result == 'success' }}
    strategy:
      matrix:
        config: ${{ fromJson(needs.discover-configs.outputs.changed-configs) }}
      fail-fast: false
    
    permissions:
      contents: read
      packages: write
      id-token: write  # Needed for OIDC token (sigstore)
      attestations: write  # Needed for attestations
      security-events: write  # Needed for Trivy SARIF upload

    steps:
      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

      - name: Set up Go
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6
        with:
          go-version-file: 'go.mod'

      - name: Set up QEMU
        uses: docker/setup-qemu-action@c7c53464625b32c7a7e944ae62b3e17d2b600130 # v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3

      - name: Install Cosign
        uses: sigstore/cosign-installer@398d4b0eeef1380460a10c8013a76f728fb906ac # v3

      - name: Install yq
        uses: mikefarah/yq@065b200af9851db0d5132f50bc10b1406ea5c0a8 # v4.50.1

      - name: Log in to Container Registry
        # Only login when we're going to push (main branch or manual trigger)
        if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata from config
        id: meta
        run: |
          config_file="${{ matrix.config }}"
          echo "config_file=$config_file" >> $GITHUB_OUTPUT
          
          # Extract protocol from directory name (first part of path)
          protocol=$(echo "$config_file" | cut -d'/' -f1)
          echo "protocol=$protocol" >> $GITHUB_OUTPUT
          
          # Extract server name from directory name (second part of path)
          server_name=$(echo "$config_file" | cut -d'/' -f2)
          echo "server_name=$server_name" >> $GITHUB_OUTPUT
          
          # Extract version from YAML file (spec.version)
          spec_version=$(yq '.spec.version' "$config_file" 2>/dev/null || echo "")
          
          # Use spec.version if available, otherwise "latest"
          if [ -n "$spec_version" ]; then
            version="$spec_version"
          else
            version="latest"
          fi
          echo "version=$version" >> $GITHUB_OUTPUT
          
          # Generate image name
          image_name="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${protocol}/${server_name}"
          echo "image_name=$image_name" >> $GITHUB_OUTPUT

      - name: Generate Dockerfile
        id: dockerfile
        run: |
          echo "Generating Dockerfile for ${{ steps.meta.outputs.config_file }}"
          
          # Create a temporary directory for the Dockerfile
          dockerfile_dir=$(mktemp -d)
          dockerfile_path="${dockerfile_dir}/Dockerfile"
          
          # Build and run dockhand to generate the Dockerfile
          go build -o /tmp/dockhand ./cmd/dockhand
          /tmp/dockhand build --config "${{ steps.meta.outputs.config_file }}" --output "${dockerfile_path}"
          
          echo "dockerfile_dir=$dockerfile_dir" >> $GITHUB_OUTPUT
          echo "dockerfile_path=$dockerfile_path" >> $GITHUB_OUTPUT
          
          # Display the generated Dockerfile for debugging
          echo "Generated Dockerfile:"
          cat "${dockerfile_path}"

      - name: Build and push Docker image
        id: build
        timeout-minutes: 30
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6
        with:
          context: ${{ steps.dockerfile.outputs.dockerfile_dir }}
          file: ${{ steps.dockerfile.outputs.dockerfile_path }}
          platforms: linux/amd64,linux/arm64
          push: ${{ github.event_name != 'pull_request' }}
          tags: |
            ${{ steps.meta.outputs.image_name }}:${{ steps.meta.outputs.version }}
            ${{ steps.meta.outputs.image_name }}:latest
          labels: |
            org.opencontainers.image.title=${{ steps.meta.outputs.server_name }}
            org.opencontainers.image.description=MCP server for ${{ steps.meta.outputs.server_name }}
            org.opencontainers.image.vendor=Stacklok
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ steps.meta.outputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          sbom: true
          provenance: true

      - name: Build single-platform image for Trivy scan
        id: build-for-scan
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6
        with:
          context: ${{ steps.dockerfile.outputs.dockerfile_dir }}
          file: ${{ steps.dockerfile.outputs.dockerfile_path }}
          load: true
          tags: local-scan:${{ steps.meta.outputs.server_name }}-${{ steps.meta.outputs.version }}
          cache-from: type=gha

      - name: Sign container images with Cosign
        if: github.event_name != 'pull_request'
        env:
          DIGEST: ${{ steps.build.outputs.digest }}
        run: |
          echo "Signing image ${{ steps.meta.outputs.image_name }}@${DIGEST}"
          cosign sign --yes ${{ steps.meta.outputs.image_name }}@${DIGEST}
          
          # Also sign the tagged versions for better UX
          cosign sign --yes ${{ steps.meta.outputs.image_name }}:${{ steps.meta.outputs.version }}
          cosign sign --yes ${{ steps.meta.outputs.image_name }}:latest
          
          echo "âœ… Images signed with Sigstore/Cosign" >> $GITHUB_STEP_SUMMARY

      - name: Download MCP security scan results
        id: download-scan
        if: github.event_name != 'pull_request'
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7
        with:
          name: mcp-scan-${{ steps.meta.outputs.server_name }}
          path: /tmp/scan-results
        continue-on-error: false  # Fail if scan results are missing

      - name: Create security scan attestation (SCAI format)
        if: github.event_name != 'pull_request'
        env:
          DIGEST: ${{ steps.build.outputs.digest }}
        run: |
          echo "Creating SCAI security scan attestation for ${{ steps.meta.outputs.image_name }}@${DIGEST}"

          # Read scanner version from scan results
          SCANNER_VERSION=""
          if [ -f /tmp/scan-results/scanner-version.txt ]; then
            SCANNER_VERSION=$(cat /tmp/scan-results/scanner-version.txt | tr -d '\n')
            echo "Scanner version: $SCANNER_VERSION"
          fi

          # Generate SCAI attestation using Python script
          # Reference: https://github.com/in-toto/attestation/blob/main/spec/predicates/scai.md
          # Note: Uses github.server_url to support GitHub Enterprise Server
          # Note: Analyzers are read from scan-summary.json (extracted from scanner output)
          python3 scripts/mcp-scan/generate_scai_attestation.py \
            /tmp/scan-results/scan-summary.json \
            "${{ steps.meta.outputs.image_name }}" \
            "${DIGEST}" \
            --config-file "${{ matrix.config }}" \
            --commit-sha "${{ github.sha }}" \
            --run-id "${{ github.run_id }}" \
            --run-url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            --producer-uri "${{ github.server_url }}/${{ github.repository }}" \
            --scanner-version "$SCANNER_VERSION" \
            --scanner-uri "https://github.com/cisco-ai-defense/mcp-scanner" \
            --validate \
            --output /tmp/security-attestation.json

          # Show the generated attestation for debugging
          echo "Generated SCAI attestation:"
          cat /tmp/security-attestation.json

          # Attest the security scan results with SCAI predicate type
          cosign attest --yes \
            --predicate /tmp/security-attestation.json \
            --type https://in-toto.io/attestation/scai/v0.3 \
            ${{ steps.meta.outputs.image_name }}@${DIGEST}

          # Extract attribute for summary
          ATTRIBUTE=$(jq -r '.predicate.attributes[0].attribute' /tmp/security-attestation.json)
          echo "âœ… SCAI security scan attestation created (${ATTRIBUTE})" >> $GITHUB_STEP_SUMMARY

          # Clean up
          rm -f /tmp/security-attestation.json

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8 # 0.33.1
        with:
          image-ref: local-scan:${{ steps.meta.outputs.server_name }}-${{ steps.meta.outputs.version }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@b20883b0cd1f46c72ae0ba6d1090936928f9fa30 # v4
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
          category: 'trivy-${{ steps.meta.outputs.server_name }}'

      - name: Generate image summary
        run: |
          echo "## Container Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Config**: ${{ steps.meta.outputs.config_file }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Protocol**: ${{ steps.meta.outputs.protocol }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Server**: ${{ steps.meta.outputs.server_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: ${{ steps.meta.outputs.image_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ steps.meta.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Platforms**: linux/amd64, linux/arm64" >> $GITHUB_STEP_SUMMARY

          if [ "${{ github.event_name }}" != "pull_request" ]; then
            echo "- **SBOM**: âœ… Attested" >> $GITHUB_STEP_SUMMARY
            echo "- **Build Provenance**: âœ… Attested" >> $GITHUB_STEP_SUMMARY
            echo "- **Security Scan**: âœ… Attested" >> $GITHUB_STEP_SUMMARY
            echo "- **Signatures**: âœ… Signed with Sigstore/Cosign" >> $GITHUB_STEP_SUMMARY
            echo "- **Trivy Scan**: âœ… Completed (see Security tab)" >> $GITHUB_STEP_SUMMARY
            echo "- **Status**: âœ… Built, pushed, signed, and attested" >> $GITHUB_STEP_SUMMARY
            echo "- **Tags**:" >> $GITHUB_STEP_SUMMARY
            echo "  - ${{ steps.meta.outputs.image_name }}:${{ steps.meta.outputs.version }}" >> $GITHUB_STEP_SUMMARY
            echo "  - ${{ steps.meta.outputs.image_name }}:latest" >> $GITHUB_STEP_SUMMARY
            echo "- **Digest**: ${{ steps.build.outputs.digest }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Trivy Scan**: âœ… Completed (see Security tab)" >> $GITHUB_STEP_SUMMARY
            echo "- **Status**: âœ… Built (not pushed - PR)" >> $GITHUB_STEP_SUMMARY
          fi

  mcp-scan-report:
    needs: mcp-security-scan
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && always()
    permissions:
      pull-requests: write
    steps:
      - name: Download all scan results
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7
        with:
          pattern: mcp-scan-*
          path: scan-artifacts

      - name: Comment PR with scan results
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            let comment = '## ðŸ”’ MCP Security Scan Results\n\n';
            let hasAnyIssues = false;
            let totalServersScanned = 0;
            let totalVulnerabilities = 0;
            
            // Find all scan summary files in the scan-artifacts directory
            const summaryFiles = [];
            const artifactsDir = 'scan-artifacts';
            
            // Debug: List all files in current directory
            console.log('Current directory contents:', fs.readdirSync('.'));
            
            if (fs.existsSync(artifactsDir)) {
              console.log('Artifacts directory exists');
              const artifactDirs = fs.readdirSync(artifactsDir);
              console.log('Artifact directories:', artifactDirs);
              
              // Check each item in the artifacts directory
              for (const item of artifactDirs) {
                const itemPath = path.join(artifactsDir, item);
                const stat = fs.statSync(itemPath);
                
                if (stat.isDirectory()) {
                  // Look for scan-summary.json in subdirectory
                  const summaryFile = path.join(itemPath, 'scan-summary.json');
                  if (fs.existsSync(summaryFile)) {
                    summaryFiles.push(summaryFile);
                    console.log('Found summary file in directory:', summaryFile);
                  } else {
                    console.log(`No scan-summary.json in ${itemPath}, contents:`, fs.readdirSync(itemPath));
                  }
                } else if (stat.isFile() && item === 'scan-summary.json') {
                  // The file is directly in the artifacts directory
                  summaryFiles.push(itemPath);
                  console.log('Found summary file directly:', itemPath);
                }
              }
            } else {
              console.log('Artifacts directory does not exist');
            }
            
            console.log('Total summary files found:', summaryFiles.length);
            
            if (summaryFiles.length === 0) {
              comment += 'âš ï¸ No MCP servers were scanned in this PR.\n';
            } else {
              for (const file of summaryFiles) {
                try {
                  const summary = JSON.parse(fs.readFileSync(file, 'utf8'));
                  totalServersScanned++;
                  
                  if (summary.status === 'passed') {
                    comment += `### âœ… ${summary.server}\n`;
                    comment += `- **Status**: Passed\n`;
                    comment += `- **Tools scanned**: ${summary.tools_scanned || 0}\n`;
                    comment += `- **Result**: No security issues detected\n\n`;
                  } else if (summary.status === 'failed') {
                    hasAnyIssues = true;
                    totalVulnerabilities += summary.blocking_count || 0;
                    comment += `### âŒ ${summary.server}\n`;
                    comment += `- **Status**: Failed\n`;
                    comment += `- **Tools scanned**: ${summary.tools_scanned || 0}\n`;
                    comment += `- **Vulnerabilities found**: ${summary.blocking_count || 0}\n`;
                    comment += '\n**Security issues detected:**\n';
                    
                    if (summary.blocking_issues) {
                      summary.blocking_issues.forEach(vuln => {
                        comment += `- **[${vuln.code}]** ${vuln.message}\n`;
                      });
                    }
                    
                    // Also show allowed issues if any
                    if (summary.allowed_issues && summary.allowed_issues.length > 0) {
                      comment += '\n**Allowed issues (not blocking):**\n';
                      summary.allowed_issues.forEach(vuln => {
                        comment += `- **[${vuln.code}]** ${vuln.message} _(Allowed: ${vuln.allowed_reason})_\n`;
                      });
                    }
                    comment += '\n';
                  } else if (summary.status === 'warning') {
                    comment += `### âš ï¸ ${summary.server}\n`;
                    comment += `- **Status**: Warning\n`;
                    comment += `- **Message**: ${summary.message}\n\n`;
                  } else {
                    comment += `### âš ï¸ ${summary.server}\n`;
                    comment += `- **Status**: Error\n`;
                    comment += `- **Message**: ${summary.message || 'Unknown error'}\n\n`;
                  }
                } catch (error) {
                  console.error(`Error parsing ${file}:`, error);
                  comment += `### âš ï¸ Error parsing scan results\n`;
                  comment += `Could not parse ${file}: ${error.message}\n\n`;
                }
              }
              
              // Add summary
              if (totalServersScanned > 0) {
                comment += '---\n';
                comment += `**Summary**: Scanned ${totalServersScanned} MCP server(s)`;
                if (hasAnyIssues) {
                  comment += `, found ${totalVulnerabilities} security issue(s).\n\n`;
                  comment += 'âš ï¸ **Action Required**: Security issues were detected. Please review and address them before merging.\n';
                } else {
                  comment += ', all passed security checks. âœ…\n';
                }
              }
            }
            
            // Find and update or create comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' && comment.body.includes('MCP Security Scan Results')
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
              console.log(`Updated existing comment #${botComment.id}`);
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
              console.log('Created new comment');
            }

  summary:
    needs: [discover-configs, verify-provenance, mcp-security-scan, build-containers]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Build Summary
        run: |
          echo "## Dockyard Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Ref**: ${{ github.ref }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Configs**: ${{ needs.discover-configs.outputs.configs }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Changed Configs**: ${{ needs.discover-configs.outputs.changed-configs }}" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.verify-provenance.result }}" == "success" ]; then
            echo "- **Provenance Verification**: âœ… All packages verified" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.verify-provenance.result }}" == "failure" ]; then
            echo "- **Provenance Verification**: âš ï¸ Some packages have provenance issues (non-blocking)" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.verify-provenance.result }}" == "skipped" ]; then
            echo "- **Provenance Verification**: â­ï¸ Skipped" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ needs.mcp-security-scan.result }}" == "success" ]; then
            echo "- **Security Scan**: âœ… All MCP servers passed security scanning" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.mcp-security-scan.result }}" == "failure" ]; then
            echo "- **Security Scan**: âŒ Some MCP servers have security issues" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.mcp-security-scan.result }}" == "skipped" ]; then
            echo "- **Security Scan**: â­ï¸ Skipped" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ needs.build-containers.result }}" == "success" ]; then
            echo "- **Build Status**: âœ… All changed containers built successfully" >> $GITHUB_STEP_SUMMARY
            echo "- **Features**:" >> $GITHUB_STEP_SUMMARY
            echo "  - ðŸ—ï¸ Multi-architecture support (amd64, arm64)" >> $GITHUB_STEP_SUMMARY
            echo "  - ðŸ“¦ SBOM (Software Bill of Materials) included" >> $GITHUB_STEP_SUMMARY
            echo "  - ðŸ” Provenance attestation for supply chain security" >> $GITHUB_STEP_SUMMARY
            echo "  - âœï¸ Sigstore/Cosign signatures for image verification" >> $GITHUB_STEP_SUMMARY
            echo "  - ðŸš€ GitHub Actions cache for faster builds" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.build-containers.result }}" == "failure" ]; then
            echo "- **Build Status**: âŒ Some containers failed to build" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.build-containers.result }}" == "skipped" ]; then
            echo "- **Build Status**: â­ï¸ No configuration changes detected" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Build Status**: âš ï¸ Build status unknown" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Add efficiency note
          changed_count=$(echo '${{ needs.discover-configs.outputs.changed-configs }}' | jq length)
          total_count=$(echo '${{ needs.discover-configs.outputs.configs }}' | jq length)
          echo "- **Efficiency**: Built $changed_count out of $total_count configurations" >> $GITHUB_STEP_SUMMARY
